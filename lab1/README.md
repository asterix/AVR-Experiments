# Solution Comments
## Wiring instructions
My system works on hard timing reference generated by cascaded timers, so an external connection needs to be made before powering the system ON. The logic used is to tick and internal timer using another one in PWM mode (used to drive the green LED on the GPIO). The same signal that drives the green LED acts as the external CLK source for an internal reference timer. Timer 3 PWM is used to clock Timer 0. Follow the below easy steps to finish wiring.

* Step 1: Remove the buzzer jumper on the board connecting PORTD7 to the buzzer.
* Step 2: Connect ```PORTD7 to PORTB6``` (same as the green GPIO LED). Schematic naming ```D6 -> D10```.
* Step 3: Make sure that the above connection is stable (not wiggling). Double check the connections. ```PORTD7 -> PORTB6 (D6 -> D10)```.

If the above wiring is not done, ALL the readings from my system WILL BE GARBAGE. So, please connect them correctly. But once done, you'll get highly accurate measurements!

NOTE: All experiments can be run error free for upto 65 seconds (when the green LED is configured to toggle every 100ms). If run longer than 65 seconds, the reported results are just unreliable.

## Answers to questions
### 1 - WCET of Hough Transform
Below are the steps I used to do the WCET analysis of Hough transform
* Step 1: Configure a hardware timer to interrupt every 25ms by overflowing.
* Step 2: Disable all interrupts except the timer used above. In the ISR count the number of overflows of the timer.
* Step 3: Implement the below pseudocode in ```main()```
```
start_timer();
hough_transform(...);
stop_timer();

time_taken_ms = 25 * num_timer_overflows + TCNT1/65536 * 25 - num_timer_overflows * (38 * CPU_CYCLE_LENGTH_MILLISEC)
```
Factors affecting WCET analysis are:
* 1 - If ```hough_transform()``` implementation has a lot of conditional paths then depending on the data set used and the paths traversed, WCET changes. To mitigate such issues, a vast data set traversing all paths should be used for analysis.

* 2 - WCET analysis is also affected by how often ```hough_transform()``` is interrupted during execution and how long the interrupting process occupies the processor. Hence during WCET analysis, frequent interruptions, long ISRs should be avoided. In my case I only increment a global variable every 25ms when the timer overflows. Depending on how long interrupt processing takes, this offset can be subtracted from the actual measurement. My ISR has the below overhead: (38 CPU cycles)
```
ISR(TIMER1_OVF_vect)
{
     72e:	1f 92       	push	r1
     730:	0f 92       	push	r0
     732:	0f b6       	in	r0, 0x3f	; 63
     734:	0f 92       	push	r0
     736:	11 24       	eor	r1, r1
     738:	8f 93       	push	r24
     73a:	9f 93       	push	r25
   timer1_ovf++;
     73c:	80 91 39 03 	lds	r24, 0x0339
     740:	90 91 3a 03 	lds	r25, 0x033A
     744:	01 96       	adiw	r24, 0x01	; 1
     746:	90 93 3a 03 	sts	0x033A, r25
     74a:	80 93 39 03 	sts	0x0339, r24
}
     74e:	9f 91       	pop	r25
     750:	8f 91       	pop	r24
     752:	0f 90       	pop	r0
     754:	0f be       	out	0x3f, r0	; 63
     756:	0f 90       	pop	r0
     758:	1f 90       	pop	r1
     75a:	18 95       	reti
```
* 3 - Overall confidence in such a controlled analysis is high, but there is always a code path traverse uncertainty which has to be accounted for. If the analysis done repeatedly on a wide range of images and averaged, then a confidence of +/- 5% should be easily achievable.

### 2 - Periods of tasks
The period of a periodic task on real-time systems is defined as the time between two releases.

* Period of Hough transform - 100ms
* Period of Red LED task    - 100ms
* Period of Yellow LED task - 100ms
* Period of Jitter LED task - undefined because this is not a periodic task. It's a sporadic task.

The period of a task is influenced by its release deadline.

### 3 - Experiment 1 based questions
Here are the results of Experiment 1:
```
----- Printing all experiment data -----
Experiment number: 1, Experimentation time (ms): 65000

1: Time keeper task:    times run:   63776  |  missed deadlines: 1224
2: Communication task:  times run:       2  |  missed deadlines: 0
3: Red LED task:        times run:     127  |  missed deadlines: 3
4: Yellow LED task:     times run:     129  |  missed deadlines: 1
5: Jitter LED task:     times run:     531  |  missed deadlines: 44
6: Green LED task:      times run:     130  |  missed deadlines: 0
7: Green count task:    times run:     130  |  missed deadlines: 0
8: Hough trans task:    times run:     637  |  missed deadlines: 13
```
* Yes, there surely is a drift between blinking of LEDs. The green LED is controlled by an independent hardware module but the other LEDs are operated in software. The software blinking takes time as instructions need to be executed. Over this, there may be interrupts just before the actual blinking deadline which may cause delays. This results in "drift".

* In my system, the LEDs weren't sync'd perfectly. This is because it takes finite time to turn each one on. The green GPIO LED controlled by the PWM module operates using dedicated hardware. Synchronizing other software controlled LEDs is hard because the instructions used to control them are not the same. Moreover, there may again be higher priority interrupts which may disturb the process of synchronization depending on how long the ISRs take to finish.

### 4 - Experiments 2-7
* Experiment 2 places a 20ms busy-wait inside green LED counting ISR. This basically results in blocking other high frequency interrupts like the timekeeping task which miss deadlines. Task releases for Hough and red LED are also affected since their releases are delayed until the green LED ISR finishes. Further more, a 20ms delay does not affect 100ms periodic ISRs much. This is seen from green LED counting task not missing any deadlines. Similarly, yellow LED task misses very few deadlines because it is released from an ISR which operates at a higher frequency than it's release. 20ms is still less than 25ms which is the period of yellow LED ISR (interrupts are saved until processed, unless overwritten by the same interrupt).
```
----- Printing all experiment data -----
Experiment number: 2, Experimentation time (ms): 17400

1: Time keeper task:    times run:   13651  |  missed deadlines: 3749
2: Communication task:  times run:       1  |  missed deadlines: 0
3: Red LED task:        times run:     135  |  missed deadlines: 39
4: Yellow LED task:     times run:     172  |  missed deadlines: 2
5: Jitter LED task:     times run:     146  |  missed deadlines: 22
6: Green LED task:      times run:     174  |  missed deadlines: 0
7: Green count task:    times run:     174  |  missed deadlines: 0
8: Hough trans task:    times run:     135  |  missed deadlines: 39
```

Experiment 3 parallels Experiment 2 in results because it is mostly the same delay placed at almost the same frequency (100ms) but in a different ISR. Hence long period ISR controlled tasks like green LED counting, yellow LED are not affected. It is very clear, as expected, that other tasks high frequency ISR controlled tasks are affected in almost the same way as in Experiment 2.
```
----- Printing all experiment data -----
Experiment number: 3, Experimentation time (ms): 15000

1: Time keeper task:    times run:   11844  |  missed deadlines: 3156
2: Communication task:  times run:       1  |  missed deadlines: 0
3: Red LED task:        times run:     117  |  missed deadlines: 33
4: Yellow LED task:     times run:     150  |  missed deadlines: 0
5: Jitter LED task:     times run:     121  |  missed deadlines: 19
6: Green LED task:      times run:     150  |  missed deadlines: 0
7: Green count task:    times run:     151  |  missed deadlines: 0
8: Hough trans task:    times run:     117  |  missed deadlines: 33
```

* Experiments 4 & 5 can be discussed together because they are similar in nature. It can be seen from Experiment 4 that a 30ms delay, which is now greater than yellow LED ISR period, starts affecting yellow LED task. This happens because while green LED ISR is busy-waiting some yellow LED interrupts are overwritten by the same interrupts coming in again. The effect on other tasks is a little more severe because the delay is higher.
```
----- Printing all experiment data -----
Experiment number: 4, Experimentation time (ms): 16600

1: Time keeper task:    times run:   11310  |  missed deadlines: 5290
2: Communication task:  times run:       1  |  missed deadlines: 0
3: Red LED task:        times run:     112  |  missed deadlines: 54
4: Yellow LED task:     times run:     124  |  missed deadlines: 42
5: Jitter LED task:     times run:      98  |  missed deadlines: 10
6: Green LED task:      times run:     166  |  missed deadlines: 0
7: Green count task:    times run:     168  |  missed deadlines: 0
8: Hough trans task:    times run:     112  |  missed deadlines: 54
```
* Experiment 5 again parallels Experiment 4. The only interesting thing to note here is that although a 30ms delay is placed in yellow LED ISR, the green LED counting task is not affected. This is due to its long 100ms period (and also higher priority). So, interrupt overrwrites happen seldon for green LED. The yellow LED task misses fewer deadlines because it is the one which causes the delay and hence it can have at most one pending interrupt which is processed immediately on exit from ISR.
```
----- Printing all experiment data -----
Experiment number: 5, Experimentation time (ms): 16200

1: Time keeper task:    times run:   10972  |  missed deadlines: 5228
2: Communication task:  times run:       1  |  missed deadlines: 0
3: Red LED task:        times run:     108  |  missed deadlines: 54
4: Yellow LED task:     times run:     161  |  missed deadlines: 1
5: Jitter LED task:     times run:     136  |  missed deadlines: 28
6: Green LED task:      times run:     162  |  missed deadlines: 0
7: Green count task:    times run:     162  |  missed deadlines: 0
8: Hough trans task:    times run:     109  |  missed deadlines: 53
```

* Experiment 6 deals with drastic disruption of the system due to large ISR execution times. About 105ms delay in the highest priority tasks' ISR basically disrupts all other tasks because the delay is larger than all ISR periods (1ms, 25ms and 100ms). Clearly the effect on high frequency ISRs is extremely severe, timekeeping task missing all its deadlines! Which further causes Hough transform and red LED tasks to miss all deadlines too. Yellow LED ISR with its 25ms period misses all releases of tasks in it too. Green LED counting task with its period of 100ms being close to 105ms delay and having the highest priority misses fewer deadlines, especially because it causes the delay here!
```
----- Printing all experiment data -----
Experiment number: 6, Experimentation time (ms): 16400

1: Time keeper task:    times run:       0  |  missed deadlines: 16400
2: Communication task:  times run:       1  |  missed deadlines: 0
3: Red LED task:        times run:       0  |  missed deadlines: 164
4: Yellow LED task:     times run:       0  |  missed deadlines: 164
5: Jitter LED task:     times run:       0  |  missed deadlines: 0
6: Green LED task:      times run:     164  |  missed deadlines: 0
7: Green count task:    times run:     143  |  missed deadlines: 21
8: Hough trans task:    times run:       0  |  missed deadlines: 164
```

* As can be seen from the results of Experiment 7, there is some allowance of high frequency interrupts although this can be a little counter-intuitive. This is however because of the nature of yellow LED ISR which delays 105ms only when the yellow LED task is scheduledm which happens on every 4th run of the ISR (although this is completely distorted because of time update lags). Hence there is some breathing space for high frequency interrupts like timekeeping tasks and also for other tasks run in the main loop. Note that green LED counting task does not miss any deadlines because its ISR has the highest service priority.
```
----- Printing all experiment data -----
Experiment number: 7, Experimentation time (ms): 17600

1: Time keeper task:    times run:    6175  |  missed deadlines: 11425
2: Communication task:  times run:       1  |  missed deadlines: 0
3: Red LED task:        times run:      60  |  missed deadlines: 116
4: Yellow LED task:     times run:     101  |  missed deadlines: 75
5: Jitter LED task:     times run:      80  |  missed deadlines: 14
6: Green LED task:      times run:     176  |  missed deadlines: 0
7: Green count task:    times run:     176  |  missed deadlines: 0
8: Hough trans task:    times run:      61  |  missed deadlines: 115
```

### 5 - Experiment 8
* Experiment 8 data just before memory (RAM) overrun corruption due to recursive interrupts flooding the stack. The CPU stops responding after about 11 seconds. We can easily see here that the timekeeping 1ms interrupt misses fewer deadlines than above indicating that it interruted the yellow LED ISR a lot to fulfill its deadlines. The yellow LED interrupt, interrupts itself too hence resulting in 0 missed deadlines. However this is exactly the behavior that causes recursive interrupts which further causes stack overflow, hence completely corrupting CPU data space. Since the ATMega32 does not have an MMU to generate memory protection exceptions, all of data space including SFRs are corrupted causing the CPU to crash.

However before this happens an interesting thing to observe here is that the large delay which caused severe disruptions in Experiment 7 is now alleviated a little because the higher frequency interrupts are allowed to interrupt the busy-waiting ISR. However, tasks are barely scheduled in the main loop because interrupts take up all of CPU's time.
```
----- Printing all experiment data -----
Experiment number: 8, Experimentation time (ms): 10200

1: Time keeper task:    times run:   10092  |  missed deadlines: 108
2: Communication task:  times run:       3  |  missed deadlines: 0
3: Red LED task:        times run:       0  |  missed deadlines: 102
4: Yellow LED task:     times run:     102  |  missed deadlines: 0
5: Jitter LED task:     times run:       1  |  missed deadlines: 52
6: Green LED task:      times run:     102  |  missed deadlines: 0
7: Green count task:    times run:     105  |  missed deadlines: 0
8: Hough trans task:    times run:       0  |  missed deadlines: 102
```

### 6 - Timing control, responsiveness of system and impact on other tasks
(a) Time driven execution inside an ISR:
- Timing control depends on the underlying timekeeping mechanism. Good when that is accurate and interrupt has high priority.
- Responsiveness is the best as interrupt driven tasks have a short response time (when not blocked)
- Impact on other tasks is high if the task takes a long time to run. ISR executed tasks should be kept short.
    
(b) Time-driven release from within the ISR:
- Timing control depends on the underlying timekeeping mechanism. Good when that is accurate and interrupt has high priority.
- Responsiveness depends on prioritization in the scheduler which actually runs the released task.
- Impact on other tasks can be better controlled as this is now a part of regular scheduled task which is accounted for.
    
(c) External interrupt based task execution in an ISR:
- Timing control is excellent since external interrupts have a very high priority.
- Responsiveness is again excellent as this is probably the best a CPU can offer. Again as a result of high priority interrupt treatment.
- Impact on other tasks depends on the time taken be the ISR. If the system is halted, then this is irrelevant. But if not then the task has to be kept short.
    
(d) Periodic polling from within an ISR and release:
- Timing control depends on the frequency of the ISR. A balance is needed between polling frequency requirements and CPU interruption.
- Responsiveness depends on prioritization in the scheduler which actually runs the released task.
- Impact on other tasks is estimated and accounted for by the scheduler which runs the task. The impact can hence be balanced.
    
